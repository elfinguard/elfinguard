package types

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"os"
	"sync"

	ecies "github.com/ecies/go/v2"
	"github.com/edgelesssys/ego/ecrypto"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/fomichev/secp256k1"
)

//go:generate msgp

//msgp:ignore RpcxReq
type RpcxReq struct { // a request to the rpcx server
	DecryptTaskToken        // send this to the server for rate control and logging
	Path             string // specifies a cloud file. Its detailed meaning depends on base protocol (IPFS, Arweave, etc)
	Index            int    // The chunk's index (the file is viewed as an array of chunks)
}

//msgp:ignore RpcxResp
type RpcxResp struct { // a response from the rpcx server
	ErrStr     string // for error report
	Chunk      []byte // the Chunk's content, at most 256KB for the last chunk, exactly 256KB for the other chunks.
	TotalBytes int    // the file's total bytes
}

// A service provides 256KB chunks of IPFS files
type ChunkGetter interface {
	GetChunk(token DecryptTaskToken, path string, index int) (chunk []byte, errStr string)
	GetTotalBytes(path string) (totalBytes int, errStr string)
}

type RateLimiter interface {
	CanServe(remoteAddr, path, query string, token, guide []byte) bool
}

// ======================= For recryptors' encryption and decryption =======================
// Guide the recryptor to get grantcode from authorizers and encrypt the shamir-split parts
//
//msgp:ignore EncryptionGuide
type EncryptionGuide struct { // All its fields are specified by the author
	ChainId        *big.Int `json:"chainid"`
	Contract       string   `json:"contract"`
	Function       string   `json:"function"`
	Threshold      int      `json:"threshold"`
	AuthorizerList []string `json:"authorizerlist"`
	OutData        []byte   `json:"outdata"`
}

// Guide the recryptor to get grantcode from authorizers and decrypt the 'EncryptedParts'
//
//msgp:ignore DecryptionGuide
type DecryptionGuide struct {
	ChainId        *big.Int `json:"chainid"`        // got from config.json of ElfinDirectory
	Contract       string   `json:"contract"`       // got from config.json of ElfinDirectory
	Function       string   `json:"function"`       // got from config.json of ElfinDirectory
	Threshold      int      `json:"threshold"`      // got from config.json of ElfinDirectory
	AuthorizerList []string `json:"authorizerlist"` // got from config.json of ElfinDirectory
	EncryptedParts [][]byte `json:"encryptedparts"` // generated by the Authorizers
	CallDataList   [][]byte `json:"calldatalist"`   // specified by the viewer
	Signature      []byte   `json:"signature"`      // signed by the viewer
	Timestamp      int64    `json:"timestamp"`      // specified by the viewer
	RecryptorSalt  []byte   `json:"recryptorsalt"`  // got from config.json of ElfinDirectory
	FileId         []byte   `json:"fileid"`         // got from config.json of ElfinDirectory
}

// The recryptor needs such a token during encrypting an author-submitted file
// To make the recrytor state-less, this token is sealed by the recryptors and stored on the client side
type EncryptTaskToken struct {
	ExpireTime    int64    `msg:"e"` // generated by recryptor
	FileId        [32]byte `msg:"f"` // specified by the author
	RecryptorSalt [32]byte `msg:"r"` // generated by recryptor
	Secret        [32]byte `msg:"s"` // generated by recryptor
	RequestorAddr [20]byte `msg:"a"` // address of the author
}

// The recryptor needs such a token during decrypting a viewer-required file
// To make the recrytor state-less, this token is sealed by the recryptors and stored on the client side
type DecryptTaskToken struct {
	ExpireTime    int64    `msg:"e"` // generated by recryptor
	FileId        [32]byte `msg:"f"` // copied from DecryptionGuide
	RecryptorSalt [32]byte `msg:"r"` // copied from DecryptionGuide
	Secret        [32]byte `msg:"s"` // got by the recryptors from shamir.Combine
	RemoteAddr    string   `msg:"a"` // got from http.Request
	ViewerAccount [20]byte `msg:"v"` // recovered from DecryptionGuide.Signature
	Contract      string   `msg:"c"` // copied from DecryptionGuide
}

//msgp:ignore AuthResult
type AuthResult struct {
	Succeeded bool   `json:"succeeded"`
	Message   string `json:"message"` // explain the error reason when Succeeded==false
	Result    []byte `json:"result"`
	Proof     []byte `json:"proof"`
	Salt      []byte `json:"salt"`   // use Salt and ECDH-generated secret to create a Cryptor for decrypting Result
	PubKey    []byte `json:"pubkey"` // authorizer's pubkey
}

// ======================================
// A binary file to store the enclave's private key
//
//msgp:ignore KeyFile
type KeyFile struct {
	filename string
}

func NewKeyFile(fn string) KeyFile {
	return KeyFile{filename: fn}
}

func (f KeyFile) RecoveryPrivateKey(isEnclaveMode bool) (privKey *ecdsa.PrivateKey) {
	fileData, err := os.ReadFile(f.filename)
	if err != nil {
		fmt.Printf("read file failed, %s\n", err.Error())
		if os.IsNotExist(err) {
			// maybe first run this enclave app
			privKey = f.generatePrivateKey(isEnclaveMode)
		}
		return
	}
	rawData := fileData
	if isEnclaveMode {
		rawData, err = ecrypto.Unseal(fileData, nil)
		if err != nil {
			fmt.Printf("unseal file data failed, %s\n", err.Error())
			return
		}
	}
	privKey, err = crypto.ToECDSA(rawData)
	if err != nil {
		panic(err)
	}
	return
}

func (f KeyFile) generatePrivateKey(isEnclaveMode bool) (privKey *ecdsa.PrivateKey) {
	privKey, err := NewRandReader().GenerateKey()
	if err != nil {
		panic(err)
	}

	pubKeyBz := crypto.CompressPubkey(&privKey.PublicKey)
	fmt.Printf("generate enclave vrf private key, its pubkey is: %s\n", hex.EncodeToString(pubKeyBz))
	f.SealKeyToFile(privKey, isEnclaveMode)
	return
}

func (f KeyFile) SealKeyToFile(privKey *ecdsa.PrivateKey, isEnclaveMode bool) {
	privSealed := crypto.FromECDSA(privKey)
	if isEnclaveMode {
		privSealedTmp, err := ecrypto.SealWithUniqueKey(crypto.FromECDSA(privKey), nil)
		if err != nil {
			panic(err)
		}
		privSealed = privSealedTmp
	}
	err := os.WriteFile(f.filename, privSealed, 0600)
	if err != nil {
		panic(err)
	}
}

// ========= authorizer-endorsed data structures ==============
//
//msgp:ignore TxInfo
type TxInfo struct {
	ChainId   *big.Int
	Timestamp *big.Int
	TxHash    common.Hash
	From      common.Address
	To        common.Address
	Value     *big.Int
	Data      []byte
}

func (ti *TxInfo) ToBytes() []byte {
	bz := make([]byte, 32*4+20*2+len(ti.Data))
	copy(bz[32*0:32*0+32], math.PaddedBigBytes(ti.ChainId, 32))
	copy(bz[32*1:32*1+32], math.PaddedBigBytes(ti.Timestamp, 32))
	copy(bz[32*2:32*2+32], ti.TxHash.Bytes())
	copy(bz[32*3:32*3+20], ti.From.Bytes())
	copy(bz[32*3+20:32*3+20*2], ti.To.Bytes())
	copy(bz[32*3+20*2:32*4+20*2], math.PaddedBigBytes(ti.Value, 32))
	copy(bz[32*4+20*2:], ti.Data)
	return bz
}

//msgp:ignore LogInfo
type LogInfo struct {
	ChainId   *big.Int
	Timestamp *big.Int
	Address   common.Address
	Topics    []common.Hash
	Data      []byte
}

func (li *LogInfo) ToBytes() []byte {
	bz := make([]byte, 32*2+21, 32*2+21+32*len(li.Topics)+len(li.Data))
	copy(bz[32*0:32*0+32], math.PaddedBigBytes(li.ChainId, 32))
	copy(bz[32*1:32*1+32], math.PaddedBigBytes(li.Timestamp, 32))
	copy(bz[32*2:32*2+20], li.Address.Bytes())
	bz[32*2+20] = byte(len(li.Topics))
	for _, t := range li.Topics {
		bz = append(bz, t[:]...)
	}
	bz = append(bz, li.Data...)
	return bz
}

//msgp:ignore EthCallInfo
type EthCallInfo struct {
	ChainId          *big.Int
	Timestamp        *big.Int
	From             common.Address
	To               common.Address
	FunctionSelector [4]byte
	OutData          []byte
}

func (ei *EthCallInfo) ToBytes() []byte {
	bz := make([]byte, 32*2+20*2, 32*2+20*2+4+len(ei.OutData))
	copy(bz[32*0:32*0+32], math.PaddedBigBytes(ei.ChainId, 32))
	copy(bz[32*1:32*1+32], math.PaddedBigBytes(ei.Timestamp, 32))
	copy(bz[32*2:32*2+20], ei.From.Bytes())
	copy(bz[32*2+20:32*2+20*2], ei.To.Bytes())
	bz = append(bz, ei.FunctionSelector[:]...)
	bz = append(bz, ei.OutData...)
	return bz
}

// ================================================================
// gvien the peer's public key, query the shared secret between me and this peer
//
//msgp:ignore EcdhCache
type EcdhCache struct {
	m     map[[33]byte][]byte
	mtx   sync.RWMutex
	limit int
}

const (
	EncapsulateSecret = uint8(iota)
	DecapsulateSecret
)

func NewEcdhCache(sizeLimit int) *EcdhCache {
	return &EcdhCache{
		m:     make(map[[33]byte][]byte, sizeLimit/4),
		limit: sizeLimit,
	}
}

func (cache *EcdhCache) GetSecret(peerPubkey [33]byte) (secret []byte, ok bool) {
	cache.mtx.RLock()
	secret, ok = cache.m[peerPubkey]
	cache.mtx.RUnlock()
	return
}

// Lookup the ecdhCache for secret. If cache misses, calculate the ECDH secret and put it into cache
func (cache *EcdhCache) PeerKeyToSecret(myKey *ecdsa.PrivateKey, peerPubkey [33]byte, encapsulateType uint8) (secret []byte, err error) {
	cache.mtx.RLock()
	if secret, ok := cache.m[peerPubkey]; ok {
		cache.mtx.RUnlock()
		return secret, nil
	}
	cache.mtx.RUnlock()

	if encapsulateType > DecapsulateSecret {
		return nil, errors.New("invalid encapsulateType type")
	}

	senderPubKey, err := ecies.NewPublicKeyFromBytes(peerPubkey[:])
	if err != nil {
		return nil, err
	}
	eciesPrivateKey := toEciesPrivKey(myKey)

	if encapsulateType == EncapsulateSecret {
		secret, err = eciesPrivateKey.Encapsulate(senderPubKey)
		if err != nil {
			return nil, err
		}

	} else if encapsulateType == DecapsulateSecret {
		secret, err = senderPubKey.Decapsulate(eciesPrivateKey)
		if err != nil {
			return nil, err
		}
	}

	cache.mtx.Lock()
	if len(cache.m) >= cache.limit {
		for key := range cache.m {
			delete(cache.m, key)
			break
		}
	}
	cache.m[peerPubkey] = secret
	cache.mtx.Unlock()
	return
}

// method only for authenticator unit test.
func (cache *EcdhCache) SetMForUT(key [33]byte, value []byte) {
	cache.m[key] = value
}

func toEciesPrivKey(myKey *ecdsa.PrivateKey) *ecies.PrivateKey {
	return &ecies.PrivateKey{ // make a deep copy
		PublicKey: &ecies.PublicKey{
			Curve: myKey.PublicKey.Curve,
			X:     myKey.PublicKey.X,
			Y:     myKey.PublicKey.Y,
		},
		D: myKey.D,
	}
}

// ===================================
// Read random data from CPU's hardware RNG (random-number-generator)
//
//msgp:ignore RandReader
type RandReader struct {
}

func NewRandReader() *RandReader {
	return &RandReader{}
}

func (r *RandReader) Read32() (salt [32]byte) {
	_, err := r.Read(salt[:])
	if err != nil {
		panic(err)
	}
	return
}

// Generate a private key from true-random-number-generator in CPU
func (r *RandReader) GenerateKey() (*ecdsa.PrivateKey, error) {
	curve := secp256k1.SECP256K1()

	p, x, y, err := elliptic.GenerateKey(curve, r)
	if err != nil {
		return nil, errors.New("cannot generate key pair")
	}

	return &ecdsa.PrivateKey{
		PublicKey: ecdsa.PublicKey{
			Curve: curve,
			X:     x,
			Y:     y,
		},
		D: new(big.Int).SetBytes(p),
	}, nil
}

// ============ Encrypt and decrypt using the AES-GCM algorithm ============
//
//msgp:ignore Cryptor
type Cryptor struct {
	key   []byte
	nonce []byte
}

func NewCryptor(salt, secret []byte) *Cryptor {
	h := sha256.New()
	h.Write(salt)
	h.Write(secret)
	res := h.Sum(nil)
	return &Cryptor{
		key:   res[16:],
		nonce: res[:16],
	}
}

func (c *Cryptor) DecryptAesCbc(cipherText []byte) ([]byte, error) {
	if len(cipherText)%aes.BlockSize != 0 {
		return nil, errors.New("cipherText is not a multiple of the block size")
	}
	block, err := aes.NewCipher(c.key)
	if err != nil {
		return nil, err
	}
	mode := cipher.NewCBCDecrypter(block, c.nonce)

	// CryptBlocks can work in-place if the two arguments are the same.
	mode.CryptBlocks(cipherText, cipherText)
	return cipherText, nil
}

func (c *Cryptor) EncryptAesCbc(cipherText []byte) ([]byte, error) {
	if len(cipherText)%aes.BlockSize != 0 {
		return nil, errors.New("cipherText is not a multiple of the block size")
	}
	block, err := aes.NewCipher(c.key)
	if err != nil {
		return nil, err
	}
	mode := cipher.NewCBCEncrypter(block, c.nonce)

	// CryptBlocks can work in-place if the two arguments are the same.
	mode.CryptBlocks(cipherText, cipherText)
	return cipherText, nil
}

func (c *Cryptor) DecryptAesGcm(cipherText []byte) ([]byte, error) {
	aesCipher, err := aes.NewCipher(c.key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(aesCipher)
	if err != nil {
		return nil, err
	}

	return gcm.Open(cipherText[:0], c.nonce[:12], cipherText, nil)
}

func (c *Cryptor) EncryptAesGcm(plainText []byte) ([]byte, error) {
	aesCipher, err := aes.NewCipher(c.key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(aesCipher)
	if err != nil {
		return nil, err
	}

	return gcm.Seal(plainText[:0], c.nonce[:12], plainText, nil), nil
}

func EncryptMessageWithNewNonce(token DecryptTaskToken, plainText []byte) ([]byte, []byte, error) {
	cryptor := NewCryptor(token.RecryptorSalt[:], token.Secret[:])
	aesCipher, err := aes.NewCipher(cryptor.key)
	if err != nil {
		return nil, nil, err
	}

	gcm, err := cipher.NewGCM(aesCipher)
	if err != nil {
		return nil, nil, err
	}

	nonceBz := NewRandReader().Read32()
	return gcm.Seal(plainText[:0], nonceBz[:12], plainText, nil), nonceBz[:], nil
}

func DecryptMessageWithNonce(token DecryptTaskToken, cipherText []byte, nonce []byte) ([]byte, error) {
	cryptor := NewCryptor(token.RecryptorSalt[:], token.Secret[:])
	aesCipher, err := aes.NewCipher(cryptor.key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(aesCipher)
	if err != nil {
		return nil, err
	}

	return gcm.Open(cipherText[:0], nonce[:12], cipherText, nil)
}
